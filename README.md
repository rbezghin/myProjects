# Leetcode prep

## Array
- ~~Two Sum - https://leetcode.com/problems/two-sum/~~
- ~~Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/~~
- ~~Contains Duplicate - https://leetcode.com/problems/contains-duplicate/~~
- ~~Product of Array Except Self - https://leetcode.com/problems/product-of-array-except-self/~~
- ~~Maximum Subarray - https://leetcode.com/problems/maximum-subarray/~~
- ~~Maximum Product Subarray - https://leetcode.com/problems/maximum-product-subarray/~~
- ~~Find Minimum in Rotated Sorted Array - https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/~~
- ~~Search in Rotated Sorted Array - https://leetcode.com/problems/search-in-rotated-sorted-array/~~
- ~~3Sum - https://leetcode.com/problems/3sum/~~
- ~~Container With Most Water - https://leetcode.com/problems/container-with-most-water/~~

---

## Binary

- Sum of Two Integers - https://leetcode.com/problems/sum-of-two-integers/
- Number of 1 Bits - https://leetcode.com/problems/number-of-1-bits/
- Counting Bits - https://leetcode.com/problems/counting-bits/
- Missing Number - https://leetcode.com/problems/missing-number/
- Reverse Bits - https://leetcode.com/problems/reverse-bits/

---

## Dynamic Programming

- Climbing Stairs - https://leetcode.com/problems/climbing-stairs/
- Coin Change - https://leetcode.com/problems/coin-change/
- Longest Increasing Subsequence - https://leetcode.com/problems/longest-increasing-subsequence/
- Longest Common Subsequence - 
- Word Break Problem - https://leetcode.com/problems/word-break/
- Combination Sum - https://leetcode.com/problems/combination-sum-iv/
- House Robber - https://leetcode.com/problems/house-robber/
- House Robber II - https://leetcode.com/problems/house-robber-ii/
- Decode Ways - https://leetcode.com/problems/decode-ways/
- Unique Paths - https://leetcode.com/problems/unique-paths/
- Jump Game - https://leetcode.com/problems/jump-game/

---

## Graph

- Clone Graph - https://leetcode.com/problems/clone-graph/
- Course Schedule - https://leetcode.com/problems/course-schedule/
- Pacific Atlantic Water Flow - https://leetcode.com/problems/pacific-atlantic-water-flow/
- Number of Islands - https://leetcode.com/problems/number-of-islands/
- Longest Consecutive Sequence - https://leetcode.com/problems/longest-consecutive-sequence/
- Alien Dictionary (Leetcode Premium) - https://leetcode.com/problems/alien-dictionary/
- Graph Valid Tree (Leetcode Premium) - https://leetcode.com/problems/graph-valid-tree/
- Number of Connected Components in an Undirected Graph (Leetcode Premium) - https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/

---

## Interval

- Insert Interval - https://leetcode.com/problems/insert-interval/
- Merge Intervals - https://leetcode.com/problems/merge-intervals/
- Non-overlapping Intervals - https://leetcode.com/problems/non-overlapping-intervals/
- Meeting Rooms (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms/
- Meeting Rooms II (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms-ii/

---

## Linked List

- Reverse a Linked List - https://leetcode.com/problems/reverse-linked-list/
- Detect Cycle in a Linked List - https://leetcode.com/problems/linked-list-cycle/
- Merge Two Sorted Lists - https://leetcode.com/problems/merge-two-sorted-lists/
- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
- Remove Nth Node From End Of List - https://leetcode.com/problems/remove-nth-node-from-end-of-list/
- Reorder List - https://leetcode.com/problems/reorder-list/

---

## Matrix

- Set Matrix Zeroes - https://leetcode.com/problems/set-matrix-zeroes/
- Spiral Matrix - https://leetcode.com/problems/spiral-matrix/
- Rotate Image - https://leetcode.com/problems/rotate-image/
- Word Search - https://leetcode.com/problems/word-search/

---

## String

- ~~Longest Substring Without Repeating Characters - https://leetcode.com/problems/longest-substring-without-repeating-characters/~~
- ~~Longest Repeating Character Replacement - https://leetcode.com/problems/longest-repeating-character-replacement/~~
- Minimum Window Substring (Hard *_* no thank you) - https://leetcode.com/problems/minimum-window-substring/
- ~~Valid Anagram - https://leetcode.com/problems/valid-anagram/~~
- ~~Group Anagrams - https://leetcode.com/problems/group-anagrams/~~
- ~~Valid Parentheses - https://leetcode.com/problems/valid-parentheses/~~
- ~~Valid Palindrome - https://leetcode.com/problems/valid-palindrome/~~
- Longest Palindromic Substring - https://leetcode.com/problems/longest-palindromic-substring/
- Palindromic Substrings - https://leetcode.com/problems/palindromic-substrings/
- Encode and Decode Strings (Leetcode Premium) - https://leetcode.com/problems/encode-and-decode-strings/

---

## Tree

- Maximum Depth of Binary Tree - https://leetcode.com/problems/maximum-depth-of-binary-tree/
- Same Tree - https://leetcode.com/problems/same-tree/
- Invert/Flip Binary Tree - https://leetcode.com/problems/invert-binary-tree/
- Binary Tree Maximum Path Sum - https://leetcode.com/problems/binary-tree-maximum-path-sum/
- Binary Tree Level Order Traversal - https://leetcode.com/problems/binary-tree-level-order-traversal/
- Serialize and Deserialize Binary Tree - https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
- Subtree of Another Tree - https://leetcode.com/problems/subtree-of-another-tree/
- Construct Binary Tree from Preorder and Inorder Traversal - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
- Validate Binary Search Tree - https://leetcode.com/problems/validate-binary-search-tree/
- Kth Smallest Element in a BST - https://leetcode.com/problems/kth-smallest-element-in-a-bst/
- Lowest Common Ancestor of BST - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
- Implement Trie (Prefix Tree) - https://leetcode.com/problems/implement-trie-prefix-tree/
- Add and Search Word - https://leetcode.com/problems/add-and-search-word-data-structure-design/
- Word Search II - https://leetcode.com/problems/word-search-ii/

---

## Heap

- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
- Top K Frequent Elements - https://leetcode.com/problems/top-k-frequent-elements/
- Find Median from Data Stream - https://leetcode.com/problems/find-median-from-data-stream/

## Solutions

## Array

### Two Sum
```
Runtime: O(n) Space: O(n)
func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    var map: [Int: Int] = [:]
    for (index, num) in nums.enumerated() {
        let numToCheck = target - num
        if let secondNumIndex = map[numToCheck] {
            return [index, secondNumIndex]
        }
        map[num] = index
    }
    return []
}
```

### Best Time to Buy and Sell Stock
```
Trick is to keep track of Min price and Max Profit

Runtime: O(n) Space: O(1)
class MaxProfit {
    func maxProfit(_ prices: [Int]) -> Int {
        var minPrice = Int.max
        var maxProfit = 0
        for price in prices {
            if price < minPrice {
                minPrice = price
            } else if price - minPrice > maxProfit {
                maxProfit = price - minPrice
            }
        }
        return maxProfit
    }
}
```
### Contains Duplicate
```
    func containsDuplicate(_ nums: [Int]) -> Bool {
        var map = [Int: Bool]()
        for num in nums {
            if let _ = map[num] {
                return true
            }
            map[num] = true
        }
        return false
    }
```
### Product Except Self
```
/*
 Trick is to create left to right products and right to left padded with 1 on left or right to skip self

 Runtime: O(n)
 Space: O(1) if we dont count result array.
 this is a more efficient emplementation because I started with 3 arrays and now down to 1
 */
func productExceptSelf(_ nums: [Int]) -> [Int] {
    var result = [1]
    for index in 1 ..< nums.count {
        result.append(nums[index-1] * result[index-1])
    }
    var currentProduct = 1
    for index in stride(from: nums.count-1, to: -1, by: -1) {
        result[index] = result[index] * currentProduct
        currentProduct *= nums[index]
    }
    return result
}
```
### Max Sub Array Sum
```
/*
 Trick - Kadanes Algorithm
 Runtime: O(n)
 Space: O(1)
 */
func maxSubArray(_ nums: [Int]) -> Int {
    if nums.isEmpty {return 0}
    if nums.isEmpty {return 0}
    var currentSum = nums[0]
    var maxSum = currentSum
    for index in 1..<nums.count {
        if currentSum + nums[index] < nums[index] {
            currentSum = nums[index]
        } else {
            currentSum += nums[index]
        }
        maxSum = max(currentSum, maxSum)
    }
    return maxSum
}
```
### Max Product Subarray
```
/*
 Trick - no trick, this one is hard -_-
 Runtime: O(n)
 Space: O(1)
 */
func maxProduct(_ nums: [Int]) -> Int {
    if nums.isEmpty {return 0}
    var result = nums.max()!
    var currentMax = 1
    var currentMin = 1
    for num in nums {
        if num == 0 {
            currentMax = 1; currentMin = 1
            continue
        }
        let temp = currentMax * num
        currentMax = max(currentMax*num, currentMin*num, num)
        currentMin = min(temp, currentMin*num, num)
        result = max(result, currentMax)
    }
    return result
}

ALTERNATIVE solution (not mine) Two pass left to right and right to left while keeping track of the max value and current prouct

public int maxProduct(int[] nums) {
int max = Integer.MIN_VALUE, product = 1;
int len = nums.length;

 for(int i = 0; i < len; i++) {
     max = Math.max(product *= nums[i], max);
     if (nums[i] == 0) product = 1;
 }

 product = 1;
 for(int i = len - 1; i >= 0; i--) {
     max = Math.max(product *= nums[i], max);
     if (nums[i] == 0) product = 1;
 }

 return max;
}
```
### 3Sum
```
/*
 Trick - Sort array, for every number in array find two sum
    use two pointers on left and right and move left if sum is smaller or move right if summ is too big
    to avoid duplicates while loop through left and right
    also check for same sumbers in the original array bc no need to look for pairs for the same number
 
    Runtime: O(n^2)
 */
func threeSum(_ nums: [Int]) -> [[Int]] {
    var result = [[Int]]()
    let nums = nums.sorted()
    for index in 0..<nums.count-2 {
        if index == 0 || ( index > 0 && nums[index] != nums[index-1]){
            let target = 0 - nums[index]
            var left = index+1
            var right = nums.count-1
            while left < right {
                if nums[left] + nums[right] == target {
                    //we found the value
                    result.append([nums[index],nums[left],nums[right]])
                    //skip duplicates
                    while (left < right && nums[left] == nums[left+1]){left += 1}
                    while (left < right && nums[right] == nums[right-1]){right -= 1}
                    left += 1
                    right -= 1
                } else if nums[left] + nums[right] > target {
                    right -= 1
                } else {
                    left += 1
                }
            }
        }
    }
    return result
}
```
```
missing a few algos...
```

### Container With Most Water
```
/*
 Trick: Two pointer...
 */
func maxArea(_ height: [Int]) -> Int {
    var maxArea = 0
    var left = 0
    var right = height.count-1
    while left < right {
        let currentArea = min(height[left], height[right]) * (right-left)
        maxArea = max(currentArea, maxArea)
        if height[left] < height[right]{
            left += 1
        } else {
            right -= 1
        }
    }
    return maxArea
}
```
## String
### Longest Substring Without Repeating Characters
```
/*
 Trick: Sliding window, two pointers to keep track of the current substring
        Set to kepe track of the characters in the substring
 Runtime: O(n) we go through array once
 Space: O(n) storing up to n characters in the Set
 */
func lengthOfLongestSubstring(_ s: String) -> Int {
    if s.count == 0 {return 0}
    if s.count < 2 {return 1}
    let string = Array(s)
    var set = Set<Character>()
    var beginning = 0
    var end = 0
    var maxLength = 0
    while end < string.count {
        //character is not in the set
        if !set.contains(string[end]) {
            set.insert(string[end])
            end += 1
            maxLength = max(set.count, maxLength)
        //we have a duplicate, move the window
        } else {
            set.remove(string[beginning])
            beginning += 1
        }
    }
    return maxLength
}
```
### Longest Repeating Character Replacement (pretty hard one)
```
/*
 Trick: Sliding window, add characters, characters with larger count determine what characters to pop out
        Map to keep track of how many charactes in the current window
 
 Runtime: O(n) we go through array once
 
 Space: O(n) storing up to n characters in the Set
 */
func characterReplacement(_ s: String, _ k: Int) -> Int {
    let string = Array(s)
    var charactersCount = [Character: Int]()
    
    var maxWindowLength = 0
    var currentCharacterCount = 0 //current character is the character with longest count
    
    var start = 0
    var end = 0
    
    while end < string.count {
        //update how many characters
        if let  _  = charactersCount[string[end]] {
            charactersCount[string[end]]! += 1
        } else {
            charactersCount[string[end]] = 1
        }
        //update current max count character
        currentCharacterCount = max(currentCharacterCount, charactersCount[string[end]]!)
        //while we dont have available replacements 'k'
        while end - start + 1 - currentCharacterCount > k {
            charactersCount[string[start]]! -= 1
            start += 1
        }
        maxWindowLength =  max(maxWindowLength, end - start + 1)
        end += 1
    }
    return maxWindowLength
}
```
### Valid Anagram
```
/*
 Trick: use map, for unicode characrters - there can be a lot of them but map fixes that issue
 
 Runtime: O(n)
 
 Space: O(n)
 */

func isAnagram(_ s: String, _ t: String) -> Bool {
    if s.count != t.count {return false}
    var sMap = [Character: Int]()
    for char in s {
        if let _ = sMap[char] {
            sMap[char]! += 1
        } else {
            sMap[char] = 1
        }
    }
    for char in t {
        if let _ = sMap[char] {
            sMap[char]! -= 1
            if sMap[char]! == 0 {
                sMap[char] = nil
            }
        } else {
            return false
        }
    }
    return sMap.isEmpty
}
```
### Group Anagrams
```
/*
 Trick: sort anagrams and store them in the map with sorted as a key and unsorted values as key array
  n = number of strings m max length of string
 Runtime: O(nmlogm)
 
 Space: O(n)
 */

func groupAnagrams(_ strs: [String]) -> [[String]] {
    var map = [String:[String]]()
    for string in strs {
        let sorted = String(string.sorted())
        if let _ = map[sorted] {
            map[sorted]?.append(string)
        } else {
            map[sorted] = [string]
        }
    }
    return map.map({$0.value})
}
```
### Valid Parentheses
```
/*
 Trick: store a mapping of opening to closing parens
 
 Runtime: O(n)
 Space: O(1)
 */

func isValid(_ s: String) -> Bool {
    var stack = [String]()
    let mapping = ["(":")", "[":"]", "{":"}"]
    for paren in s {
        //if opening paren
        if let _ = mapping[String(paren)] {
            stack.append(String(paren))
        } else { //opening paren
            if let potentialMatch = stack.popLast() {
                if mapping[potentialMatch] != String(paren) {
                    return false
                }
            } else {
                return false
            }
        }
    }
    return stack.isEmpty
}
```
### Valid Palindrome
```
/*
 Trick: ehh 
 
 Runtime: O(n)
 Space: O(1)
 */
func isPalindrome(_ s: String) -> Bool {
    let s = Array(s)
    var left = 0
    var right = s.count-1
    while left < right {
        if !s[left].isLetter && !s[left].isNumber{
            left += 1
        } else if !s[right].isLetter && !s[right].isNumber{
            right -= 1
        } else if s[right].lowercased() != s[left].lowercased() {
            return false
        } else {
            left += 1
            right -= 1
        }
    }
    return true
}
```
